#!/usr/bin/python2.7
from ftplib import FTP
from PIL import Image
import time, sys, datetime, re, json, os
import mysql.connector
from mysql.connector import errorcode

# Author: Sonny Monti.
# This Python script is intended to execute as a process to keep the database of
# pictues always up to date with the FTP folder, it links microclimate conditions with the pictures, and prepare them to be viewed 
# by the user, the script also generates thumbnails that are placed locally in the folder assets and uploaded in the ftp pictures.
# to run the script simply go with a terminal in the folder containig it (/protected/dolphin/hyper-images) and type ./database_updater.py
# but the program is intended to run always so instead of './database_updater.py' type	'daemon -r database_updater.py.
# To stop it, type 'ps' check the process id of database_updater and kill it.



# a JSON parser used to generate json from txt.
FLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL
WHITESPACE = re.compile(r'[ \t\n\r]*', FLAGS)

class ConcatJSONDecoder(json.JSONDecoder):
	def decode(self, s, _w=WHITESPACE.match):
		s_len = len(s)
		objs = []
		end = 0
		while end != s_len:
		    obj, end = self.raw_decode(s, idx=_w(s, end).end())
		    end = _w(s, end).end()
		    objs.append(obj)
		return objs



# This method is used once to create the hased login data file, called loghash.txt
# The hashed file is generated from an input text file called usrdata.txt
# the input file must follow this structure:
# FTP_HOST=<ftp server host>
# FTP_USER=<ftp username>
# FTP_PASSWORD=<ftp password>
# BASE_FOLDER=<ftp base folder of enogram, containing all crops collections>
# DB_USER=<database user>
# DB_PASSWORD=<database password>
# DB=<database name>
# DB_HOST=<database host>
FTP_HOST=None
FTP_USER=None
FTP_PASSWORD=None
BASE_FOLDER=None
DB_USER=None
DB_PASSWORD=None
DB=None
DB_HOST=None
def encodeLogin():
	import base64
	f = open('usrdata.txt', 'r')
	f1 = open('loghash.txt', 'w')
	base64.encode(f, f1)

# This method decodes the encoded login txt file generated by encodeLogin()
def decodeLogin():
	import StringIO
	import base64
	f = open('loghash.txt', 'r')
	output = StringIO.StringIO()
	base64.decode(f, output)
	value = output.getvalue()
	print(value)
	elements = value.split('\n')
	print(len(elements))
	if(len(elements) >= 8):
		global BASE_FOLDER, FTP_HOST, FTP_PASSWORD, FTP_USER, DB, DB_HOST, DB_USER, DB_PASSWORD
		for i in elements:
			if(i != ''):
				name, content = i.split('=')
			print("NAME IS: "+name+" CONTENT IS "+content)
			if name == 'FTP_HOST':
				FTP_HOST = content
			elif name == 'FTP_PASSWORD':
				FTP_PASSWORD = content
			elif name =='FTP_USER':
				FTP_USER = content
			elif name == 'BASE_FOLDER':
				BASE_FOLDER = content
			elif name == 'DB_USER':
				DB_USER = content
			elif name == 'DB_PASSWORD':
				DB_PASSWORD = content
			elif name == 'DB':
				DB = content
			elif name == 'DB_HOST':
				DB_HOST = content
			else:
				return False;
		f.close()
		if(FTP_USER and FTP_HOST and FTP_PASSWORD and BASE_FOLDER and
			DB_HOST and DB and DB_PASSWORD and DB_USER):
			connectToMysql()
			return True
		else:
			print("LOGIN ERROR: the file loghash.txt is corrupted, please restore it with function encodeLogin")
			return False
	else:
		return False

#this function gets all the data_sources, the closer to a picture is needed to link the microclimate conditions to it.
def crop_dict(cnx, cursor):
	try:
		cursor.execute(queryCrop)
		ret = cursor.fetchall()
		return ret
		
	except mysql.connector.Error as err:
		print(err)

# This function has two modes: the first (if flag is True) searches the closer data_source to a picture and returns it.
# if flag is False the function returns a dictionary that represents all the sensors linked to a data source, 
# that can be more than one for i.e temperature or humidity, at this point the function searches for the closer sensor
# to the picture, if sensor has coordinates, otherwise if no sensor has coordinates, the function returns a list, of all the sensors,
# for each sensor type, that will be needed to compute a average of their values.
# to check the distance the program does the Haversine formula, there is also a  cartesian point distance, but it's commented.
def getCloser(dit, lat, lon, flag):
	import math
	check = 0
	sens = 0
	distance = 0
	data_source = None
	R = 6373 #earth radius
	lat = (lat * math.pi)/180
	lon = (lon * math.pi)/180
    	if flag == True:
        	for i in dit:
            		if len(i) == 3:
                		str_coords = str(i[0]).split(';')
                		if len(str_coords) == 2:
                        		data_source_lat = (float(str_coords[0]) * math.pi)/180
				        data_source_lon = (float(str_coords[1]) * math.pi)/180
				        data_source_id = i[1]
				        dlon = data_source_lon - lon
				        dlat = data_source_lat - lat
				        a = (math.pow(math.sin(dlat/2),2) + math.cos(lat) * math.cos(data_source_lat) * math.pow(math.sin(dlon/2),2))
				        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
				        if check == 0:
						# distance = abs(math.sqrt(math.pow(lat - data_source_lat, 2) + math.pow(lon - data_source_lon,2)))
						distance = R * c
						check+=1
						data_source = data_source_id
				        else:
				            	# new_distance = abs(math.sqrt(math.pow(lat - data_source_lat, 2) + math.pow(lon - data_source_lon,2)))                
				            	new_distance = R * c
				            	if new_distance < distance:
				                	distance = new_distance
				                	data_source = data_source_id
		return data_source
	else:	
		temp_aw = []
		temp_sens = None
		temp_dist = None
		hum_aw = []
		hum_sens = None
		hum_dist = None
		lw_aw = []
		lw_sens = None
		lw_dist = None
		mm_aw = []
		mm_sens = None
		mm_dist = None

		last_sens_type = None
		for i in dit:
			print(i)
			if len(i) == 3:
				if i[2]:
					str_coords = str(i[2]).split(';')
					if len(str_coords) == 2:
						sens_lat = (float(str_coords[0]) * math.pi)/180
						sens_lon = (float(str_coords[1]) * math.pi)/180
						sens_id = i[0]
						sens_type = i[1]
						if sens_type != last_sens_type:
							check = 0
							last_sens_type = sens_type
						dlon = sens_lon - lon
						dlat = sens_lat - lat
						a = (math.pow(math.sin(dlat/2),2) + math.cos(lat) * math.cos(sens_lat) * math.pow(math.sin(dlon/2),2))
						c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
						if check == 0:
							# distance = abs(math.sqrt(math.pow(lat - sens_lat, 2) + math.pow(lon - sens_lon,2)))
							distance = R * c
							check+=1
							if sens_type == 1:
								temp_sens = sens_id
								temp_dist = distance
							elif sens_type == 2:
								hum_sens = sens_id
								hum_dist = distance
							elif sens_type == 3:
								mm_sens = sens_id
								mm_dist = distance
							elif sens_type == 4:
								lw_sens = sens_id
								lw_dist = distance
							else:
								print("Unknown sensor type")
						
						else:
							# new_distance = abs(math.sqrt(math.pow(lat - sens_lat, 2) + math.pow(lon - sens_lon,2)))                
							new_distance = R * c
							if sens_type == 1:
								if new_distance < temp_dist:
									temp_sens = sens_id
									temp_dist = new_distance
							elif sens_type == 2:
								if new_distance < hum_dist:
									hum_sens = sens_id
									hum_dist = new_distance
							elif sens_type == 3:
								if new_distance < mm_dist:
									mm_sens = sens_id
									mm_dist = new_distance
							elif sens_type == 4:
								if new_distance < lw_dist:
									lw_sens = sens_id
									lw_dist = new_distance
							else:
								print("Unknown sensor type")
	    			else:
					sens_id = i[0]
					sens_type = i[1]
					if sens_type == 1:
						temp_aw.append(sens_id)
					elif sens_type == 2:
						hum_aw.append(sens_id)
					elif sens_type == 3:
						mm_aw.append(sens_id)
					elif sens_type == 4:
						lw_aw.append(sens_id)
					else:
						print("Unknown sensor type")
	out = {}
	if temp_sens:
		out[1] = [temp_sens]
	else:
		if len(temp_aw) > 0:
			out[1] = temp_aw
		else:
			out[1] = None
	if hum_sens:
		out[2] = [hum_sens]
	else:
		if len(hum_aw) > 0:
			out[2] = hum_aw
		else:
			out[2] = None
	if mm_sens:
		out[3] = [mm_sens]
	else:
		if len(mm_aw) > 0:
			out[3] = mm_aw
		else:
			out[3] = None
	if lw_sens:
		out[4] = [lw_sens];
	else:
		if len(lw_aw) > 0:
			out[4] = lw_aw
		else:
			out[4] = None
	return out

# This function takes a picture name and generates the tumbnail for that picture
# the size of the picture is of 1000x1000 and pictures are automatically scaled
# the size is around 100 kb
def thumbnailer(filename):
    	size = 1000,1000 
    	outfile = os.path.splitext(filename)[0] + "-thumbnail.jpg"
    	if filename != outfile:
        	try:
		    	im = Image.open(filename)
		    	im.thumbnail(size, Image.ANTIALIAS)
		    	im.save(outfile, "JPEG")
		    	print("created thumbnail for", filename)
			return outfile
        	except IOError:
            		print("cannot create thumbnail for", filename)
			return False

# THis method connects to the ftp folder, and uses the json representing it to locate the pictures in ftp
# get their coordinates, timestamp, user, device, collection name, picture name and related microclimate conditions.
# it downloads the full size image to generate the thumbnail, uploads it to ftp and keep a local copy in predivine/assets.
# When all this is done the function inserts a record in mysql table CropPictures. 
def add_collection_to_db(cnx, ftp, cursor, crop, author, date, name, db_data_source):
	try:
		pictures = []
		ftp.cwd(name)
		ftp.retrlines('NLST', pictures.append)
		pictures.pop(0)
		pictures.pop(0)
		for i in pictures:
			if('.txt' in i):
				#print("JSON File is: "+i)
				f = open('tmp.txt', 'wb+')
				ftp.retrbinary('RETR '+i, f.write)
				f.close()
				f = open('tmp.txt','r')
				jsonData = json.load(f, cls=ConcatJSONDecoder)
				if 'device' in jsonData[0]:
					device = str(jsonData[0]['device'])
				if 'pictures' in jsonData[0]:
					for j in jsonData[0]['pictures']:
						if len(j) == 3:
							if 'name' in j: 
								picture_name = str(j['name'])
								picture_datetime = picture_name[0:21]
								year, month, day, hour, minute, second, msecond = picture_datetime.split("_")
								picture_datetime = datetime.datetime(int(year),int(month),int(day),int(hour),int(minute),int(second), int(msecond))
								picture_time = datetime.time(int(hour),int(minute),int(second))
								picture_date = datetime.date(int(year),int(month),int(day))
								
								latitude = None
								longitude = None
								temperature = None
								tempdate = None
								humidity = None
								humdate = None
								lw = None
								lwdate = None
								rain = None
								raindate = None
								if j['latitude']:
									latitude = float(j['latitude'])
								if j['longitude']:
									longitude = float(j['longitude'])
								print("FILE INFORMATIONS:")
								print(picture_name, picture_datetime, latitude,longitude, author, device, date, name, crop)
								print("CLOSER CROP")
								if latitude and longitude:
									closer_data_source = getCloser(db_data_source, latitude, longitude, True)
									print(closer_data_source)
									if closer_data_source:
										cursor.execute(queryFindSensors, (int(closer_data_source),))
										print("Avaiable Sensors")
										sensors = cursor.fetchall()
										sensors = sorted(sensors, key=lambda tup: tup[1])
										print("SENSORS",sensors)
										closer_sensors = getCloser(sensors, latitude, longitude, False)
										print("SENSORS",closer_sensors)
										for k in closer_sensors:
											print(k)
											print(closer_sensors[k])
										for k in sensors:
											print(k)
										if 1 or 2 or 3 or 4 in closer_sensors:
											if closer_sensors[1]:
												awg = None
												sensori = 0
												for l in closer_sensors[1]:
													cursor.execute(queryFindDates,(int(l),picture_datetime,picture_datetime))											
													if cursor.fetchone():
														awg = 0
													for q in cursor:
														if q[0] == picture_date:
															print("same day")
															cursor.execute(queryFindData, (int(l), picture_date,picture_time))
															tempdata = cursor.fetchone()
															if tempdata:
																tempdate, temperature = tempdata
																awg += temperature
													sensori+=1
												if awg:
													temperature = awg/sensori
												print("TEMP: ",tempdate,temperature)
											if closer_sensors[2]:
												awg = None
												sensori = 0
												for l in closer_sensors[2]:
													cursor.execute(queryFindDates,(int(l),picture_datetime,picture_datetime))
													if cursor.fetchone():
														awg = 0
													for q in cursor:
														if q[0] == picture_date:
															print("same day")
															cursor.execute(queryFindData, (int(l), picture_date,picture_time))
															humdata = cursor.fetchone()
															if humdata:
																humdate, humidity = humdata
																awg += humidity
													sensori+=1
												if awg:
													humidity = awg/sensori
												print("HUM: ",humdate,humidity)
											if closer_sensors[3]:
												awg = None
												sensori = 0
												for l in closer_sensors[3]:
													cursor.execute(queryFindDates,(int(l),picture_datetime,picture_datetime))
													if cursor.fetchone():
														awg = 0
													for q in cursor:
														print(str(q[0]))
														if q[0] == picture_date:
															print("same day")
															cursor.execute(queryFindData, (int(l), picture_date,picture_time))
															lwdata = cursor.fetchone()
															if lwdata:
																lwdate, lw = lwdata
																awg += lw
													sensori+=1
												if awg:
													lw = awg/sensori
												print("LW: ",lwdate,lw)
											if closer_sensors[4]:
												awg = None
												sensori = 0
												for l in closer_sensors[4]:
													cursor.execute(queryFindDates,(int(l),picture_datetime,picture_datetime))
													if cursor.fetchone():
														awg = 0
													for q in cursor:
														print(str(q[0]))
														if q[0] == picture_date:
															print("same day")
															cursor.execute(queryFindData, (int(l), picture_date,picture_time))
															raindata = cursor.fetchone()
															if raindata:
																raindate, rain = raindata
																awg += rain
													sensori+=1
												if awg:
													rain = awg/sensori
												print("RAIN: ",rain,raindate)

															
														
								img = open('../../../assets/'+picture_name,'wb+')
								try:
									ftp.retrbinary('RETR '+picture_name, img.write)
								except Exception, e:
									print(str(e), "Picture not found")
								img.close()
								thumb = thumbnailer('../../../assets/'+picture_name)
								if(thumb):
									print('Uploading '+thumb+' to ftp folder')
									ftp.storbinary('STOR '+(thumb.split('/')[-1]), open(thumb, 'rb'))
									#os.remove(thumb)
									print('uploaded')
								os.remove('../../../assets/'+picture_name)
								insert_data = (crop, picture_datetime, date, name, "/"+"enogram/"+crop+'/'+name+'/'+picture_name, latitude, longitude, device, author, None, temperature, tempdate, humidity, humdate, lw, lwdate, rain, raindate)
								print("MYSQL RECORD: ", insert_data)
								cursor.execute(queryInsert,insert_data)
							
						else:
							print("Malformed Picture in JSON: "+ i+".") 
					
				f.close()
				os.remove('tmp.txt')
	except Exception, e:
		print str(e)
        	sys.exit(1)

# This function, checks the ftp folder and looks for new collections of pictures,
# if a new one is found, it calls add_collection_to_db to add it in the db and generate thumbnails
def connectToFtp(host, password, user, basefolder, cnx, cursor):
	crops = []
	try:
		ftp = FTP(host)     # connect to host, default port
		ftp.login(user,password)                     # login
		ftp.cwd(basefolder)               # change into "basefolder" directory
		# ftp.retrlines('LIST')           # list directory contents
		ftp.retrlines('NLST', crops.append) # get crop folders
		crops.pop(0)
		crops.pop(0) # this pops remove the folder pointers to itself and his predecessor
		db_data_source = crop_dict(cnx, cursor)
		for crop in crops:
			print("Crop: "+crop)
			collections = []
			ftp.cwd(crop)
			ftp.retrlines('NLST', collections.append)
			collections.pop(0)
			collections.pop(0)
			for i in collections:
				print("Searching collection: "+i+". in db") 
				cursor.execute(queryCropPics, (crop,i))
				if cursor.rowcount <= 0:
					print("collection "+i+". In crop: "+crop+". not in Db")
					collection_info = i.split('#')
					if(len(collection_info) == 2):
						collection_date = collection_info[0]
						author = collection_info[1]
						print("Raw date: "+collection_date, "Author: "+author)
						year, month, day, hour, minute, second = collection_date.split("_")
						date = datetime.datetime(int(year),int(month),int(day),int(hour),int(minute),int(second))
						print(date)
						add_collection_to_db(cnx, ftp, cursor, crop, author, date, i, db_data_source)
						ftp.cwd('..')
			ftp.cwd(basefolder)
	except Exception, e:
		print str(e)
        	sys.exit(1)
	finally:
		if ftp:
			ftp.quit()
			print("FTP closed")
	return crops

# These are all the query used in mysql

queryCrop = ("SELECT coordinates, id_data_source, altitude FROM predivine.data_source" )

queryInsertPicture = ("INSERT INTO employees "
	"(first_name, last_name, hire_date, gender, birth_date) "
	"VALUES (%s, %s, %s, %s, %s)")

queryCropPics = ("SELECT * FROM CropPictures WHERE CropName = %s AND SequenceName = %s")

queryFindSensors = ("SELECT id_sensor, type_id, coordinates"
		" FROM predivine.sensor"
		" WHERE data_source_id = %s;")

queryFindDates = ("SELECT DISTINCT date_sample FROM sensor_data"
		" WHERE sensor_id = %s AND"
		" ts_sample BETWEEN"
		" DATE(DATE_ADD(%s, INTERVAL -1 DAY)) AND DATE(DATE_ADD(%s, INTERVAL +2 DAY));")

queryFindData = ("SELECT ts_sample, sample_value FROM sensor_data"
		" WHERE sensor_id = %s"
		" AND date_sample = %s"
		" ORDER BY ABS(TIMEDIFF(%s, hour_sample))"
		" LIMIT 1;")
queryInsert = ("INSERT INTO CropPictures"
               	" (CropName, PictureDate, SequenceDate, SequenceName, Picturepath, Latitude, Longitude, Device, User, ReceivedTS, Temperature, TempDate, Humidity, HumDate, LW, LWDate, Rain, RainDate)"
               	" VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s);")

CropPicturesTable = (
	"  CREATE TABLE CropPictures ("
	"  Id INT NOT NULL AUTO_INCREMENT,"
	"  CropName varchar(64) NOT NULL,"
	"  PictureDate datetime NOT NULL,"
	"  SequenceDate datetime NOT NULL,"
	"  SequenceName varchar(255) NOT NULL,"
	"  Picturepath varchar(255), "
	"  Latitude float,"
	"  Longitude float,"
	"  Device varchar(255),"
	"  User varchar(64),"
	"  ReceivedTS datetime,"
	"  Temperature float,"
	"  TempDate datetime,"
	"  Humidity float,"
	"  HumDate datetime,"
	"  LW float,"
	"  LWDate datetime,"
	"  Rain float,"
	"  RainDate datetime,"
	"  PRIMARY KEY(Id)"
    	"  ) ENGINE=InnoDB")

# This function connects to Mysql predivine 
def connectToMysql():
	cursor = None
	cnx = None
	try:
		cnx = mysql.connector.connect(user=DB_USER, password=DB_PASSWORD, host=DB_HOST, database=DB)
		if cnx:
			print("connected to database: "+DB)
			cursor = cnx.cursor(buffered=True)
		if cursor:
			cursor.execute("SHOW TABLES LIKE 'CropPictures'")
			if(cursor.rowcount <= 0):
				print("ciao")
				cursor.execute(CropPicturesTable)
			lista = connectToFtp(FTP_HOST,FTP_PASSWORD,FTP_USER,BASE_FOLDER, cnx, cursor)
					
	except mysql.connector.Error as err:
  		if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
    			print("Something is wrong with your user name or password")
  		elif err.errno == errorcode.ER_BAD_DB_ERROR:
    			print("Database does not exist")
  		else:
   			print(err)
	finally:    
		if cnx:
			cnx.commit()
			cnx.close()
			print("Connection with database closed")
		if cursor:
			cursor.close()


def internet_on():
	import urllib2
    	try:
        	urllib2.urlopen('http://216.58.192.142', timeout=1)
        	return True
    	except urllib2.URLError as err: 
        	return False

if internet_on():
	decodeLogin()
else:
	print("NO INTERNET CONNECTION")



